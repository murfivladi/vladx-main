/**
 * Продвинутые примеры VladX
 * Демонстрация мощных возможностей языка
 */

// ========== РЕКУРСИЯ И ЗАМЫКАНИЯ ==========

// Классическая задача: числа Фибоначчи
// Это тест на работоспособность замыканий и рекурсии
функция фибоначчи(n) {
    если (n < 2) {
        вернуть n
    }
    вернуть фибоначчи(n - 1) + фибоначчи(n - 2)
}

печать("Фибоначчи(10) = " + фибоначчи(10))  // 55
печать("Фибоначчи(15) = " + фибоначчи(15))  // 987
печать("Фибоначчи(20) = " + фибоначчи(20))  // 6765

// Факториал
функция факториал(n) {
    если (n <= 1) {
        вернуть 1
    }
    вернуть n * факториал(n - 1)
}

печать("Факториал(10) = " + факториал(10))  // 3628800

// Мемоизированный Фибоначчи (демонстрация мемоизации)
функция мемоФибоначчи() {
    пусть кэш = {}
    
    функция вычислить(n) {
        если (кэш[n] !== undefined) {
            вернуть кэш[n]
        }
        если (n < 2) {
            кэш[n] = n
        } иначе {
            кэш[n] = вычислить(n - 1) + вычислить(n - 2)
        }
        вернуть кэш[n]
    }
    
    вернуть вычислить
}

пусть быстрыйФиб = мемоФибоначчи()
пусть старт = время()
печать("МемоФибоначчи(40) = " + быстрыйФиб(40))
пусть конец = время()
печать("Время выполнения: " + (конец - старт) + "мс")

// ========== КЛАССЫ И ООП ==========

// Базовый класс "Транспорт"
класс Транспорт {
    конструктор(тип, скорость) {
        это.тип = тип
        это.скорость = скорость
    }
    
    получитьОписание() {
        вернуть это.тип + " со скоростью " + это.скорость + " км/ч"
    }
    
    движаться() {
        вернуть это.тип + " движется..."
    }
}

// Класс "Автомобиль" наследует "Транспорт"
класс Автомобиль наследует Транспорт {
    конструктор(марка, модель, скорость) {
        супер("Автомобиль", скорость)
        это.марка = марка
        это.модель = модель
    }
    
    получитьОписание() {
        вернуть супер.получитьОписание() + " (" + это.марка + " " + это.модель + ")"
    }
    
    сигналить() {
        вернуть "Бип-бип!"
    }
}

// Класс "Электромобиль" наследует "Автомобиль"
класс Электромобиль наследует Автомобиль {
    конструктор(марка, модель) {
        супер(марка, модель, 150)
        это.заряд = 100
    }
    
    движаться() {
        вернуть "Электромобиль " + это.марка + " едет бесшумно..."
    }
    
    зарядить(процент) {
        это.заряд = это.заряд + процент
        если (это.заряд > 100) {
            это.заряд = 100
        }
        вернуть "Заряд: " + это.заряд + "%"
    }
}

// Тестирование ООП
пусть мояМашина = новый Автомобиль("Тойота", "Камри", 180)
печать(мояМашина.получитьОписание())
печать(мояМашина.сигналить())

пусть мойЭлектромобиль = новый Электромобиль("Тесла", "Модель S")
печать(мойЭлектромобиль.движаться())
печать(мойЭлектромобиль.зарядить(30))

// ========== КОЛЛЕКЦИИ И АЛГОРИТМЫ ==========

// Бинарный поиск
функция бинарныйПоиск(массив, цель) {
    пусть левый = 0
    пусть правый = длина(массив) - 1
    
    пока (левый <= правый) {
        пусть середина = пол((левый + правый) / 2)
        
        если (массив[середина] == цель) {
            вернуть середина
        }
        
        если (массив[середина] < цель) {
            левый = середина + 1
        } иначе {
            правый = середина - 1
        }
    }
    
    вернуть -1  // Не найден
}

пусть отсортированный = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
пусть индекс = бинарныйПоиск(отсортированный, 13)
печать("Индекс элемента 13: " + индекс)  // 6

// Быстрая сортировка (quicksort)
функция быстраяСортировка(массив) {
    если (длина(массив) <= 1) {
        вернуть массив
    }
    
    пусть опорный = массив[0]
    пусть меньше = фильтр(массив, (x) => x < опорный)
    пусть равно = фильтр(массив, (x) => x == опорный)
    пусть больше = фильтр(массив, (x) => x > опорный)
    
    вернуть объединить(быстраяСортировка(меньше), равно, быстраяСортировка(больше))
}

пусть неотсортированный = [64, 34, 25, 12, 22, 11, 90]
пусть отсортированныйРезультат = быстраяСортировка(неотсортированный)
печать("Отсортировано: " + разкод(отсортированныйРезультат))

// ========== ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ ==========

// Каррирование
функция каррировать(функция) {
    функция каррированная(...аргументы) {
        если (длина(аргументов) >= функция.length) {
            вернуть функция(...аргументы)
        }
        вернуть (...оставшиеся) => каррированная(...аргументы, ...оставшиеся)
    }
    вернуть каррированная
}

функция сложитьТри(a, b, c) = a + b + c
пусть каррированноеСложение = каррировать(сложитьТри)
пусть добавить10 = каррированноеСложение(10)
пусть добавить10И20 = добавить10(20)
печать("Каррированное сложение: " + добавить10И20(5))  // 35

// Конвейер обработки данных
функция обработатьДанные(данные) {
    вернуть труба(данные,
        (x) => фильтр(x, (элемент) => элемент > 0),      // Только положительные
        (x) => отобразить(x, (элемент) => элемент * 2),   // Умножить на 2
        (x) => уменьшить(x, (акк, элемент) => акк + элемент, 0)  // Сумма
    )
}

пусть сырыеДанные = [-5, 10, -3, 8, -1, 15, -7]
пусть результатКонвейера = обработатьДанные(сырыеДанные)
печать("Результат конвейера: " + результатКонвейера)

// ========== ГЕНЕРАТОРЫ ==========

// Генератор простых чисел
функция генПростые(limit) {
    функция этоПростое(n) {
        если (n < 2) вернуть ложь
        для (пусть i = 2; i * i <= n; i = i + 1) {
            если (n % i == 0) вернуть ложь
        }
        вернуть истина
    }
    
    для (пусть i = 2; i < limit; i = i + 1) {
        если (этоПростое(i)) {
            вернуть i
        }
    }
}

// Вывод первых 10 простых чисел
печать("Первые 10 простых чисел:")
пусть счетчикПростых = 0
пусть число = 2
пусть простые = []

пока (счетчикПростых < 10) {
    если (этоЧисло(число)) {  // Проверка через встроенную функцию
        простые.push(число)
        счетчикПростых = счетчикПростых + 1
    }
    число = число + 1
}

// Фибоначчи через генератор
функция* генФибоначчи(limit) {
    пусть a = 0
    пусть b = 1
    для (пусть i = 0; i < limit; i = i + 1) {
        пусть текущий = a
        a = b
        b = текущий + b
        yield текущий
    }
}

// ========== ОБРАБОТКА ОШИБОК ==========

функция безопасноеДеление(числитель, знаменатель) {
    попытка {
        если (знаменатель == 0) {
            бросить новый Ошибка("Деление на ноль!")
        }
        вернуть числитель / знаменатель
    } исключение (ошибка) {
        вернуть null
    }
}

печать("10 / 2 = " + безопасноеДеление(10, 2))     // 5
печать("10 / 0 = " + безопасноеДеление(10, 0))     // null

// Валидация данных
функция валидироватьПользователя(пользователь) {
    пусть ошибки = []
    
    если (пользователь.возраст < 18) {
        ошибки.push("Пользователь должен быть совершеннолетним")
    }
    
    если (длина(пользователь.имя) < 2) {
        ошибки.push("Имя слишком короткое")
    }
    
    если (длина(ошибки) > 0) {
        бросить новый Ошибка(соединить(ошибки, "; "))
    }
    
    вернуть истина
}

попытка {
    пусть пользователь = { имя: "А", возраст: 15 }
    валидироватьПользователя(пользователь)
} исключение (ошибка) {
    печать("Ошибка валидации: " + ошибка)
}

// ========== КОНЕЦ ПРИМЕРА ==========

печать("\n========================================")
печать("Продвинутые примеры выполнены!")
печать("========================================\n")
